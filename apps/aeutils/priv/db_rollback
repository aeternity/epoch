#!/usr/bin/env escript
%% -*- erlang-indent-level: 4; indent-tabs-mode: nil -*-

-mode(compile).

%% See https://hexdocs.pm/argparse/
%% Argparse supports a hierarchical structure of commands and subcommands, each
%% with its own arguments. This spec (no command specified) describes the top level.
%%
%% We only provide the user-level arguments. The node connection arguments, which
%% are automatically 
spec() -> #{ arguments => args() }.

args() ->
    [ #{ name => height, short => $h, long => "-height"   , required => false,
         type => int   , help => "Chain height, from which to start deleting"}
    , #{ name => hash  , short => $b, long => "-blockhash", required => false,
         type => string, help => "Keyblock hash, from which to start deleting"}
    ].


main(Args) ->
    Opts = aeu_ext_scripts:parse_opts(Args, spec()),
    {ok, Node} = aeu_ext_scripts:connect_node(Opts),
    rollback(Node, Opts).

rollback(Node, #{opts := Opts}) ->
    TopHeight = rpc:call(Node, aec_chain, top_height, []),
    TopHash   = rpc:call(Node, aec_chain, top_block_hash, []),
    EncHash = aeser_api_encoder:encode(key_block_hash, TopHash),
    St = #{ top_height => TopHeight
          , top_hash   => TopHash
          , enc_top_hash => EncHash },
    io:fwrite("Current top (height: ~p): ~s~n", [TopHeight, EncHash]),
    case Opts of
        #{height := H} when H > TopHeight ->
            abort("Specified height exceeds current top height (~p)", [TopHeight]);
        #{height := H} ->
            case rpc:call(Node, aec_chain, get_key_header_by_height, [H]) of
                {ok, Hdr} ->
                    St1 = St#{ from => #{ height => H
                                        , header => Hdr }},
                    do_rollback(St1, Node, Opts)
            end;
        #{hash := Hash} ->
            case aeser_api_encoder:safe_decode(key_block_hash, Hash) of
                {error, _} ->
                    abort("Specified hash is not a valid keyblock hash");
                {ok, DecHash} ->
                    case rpc:call(Node, aec_chain, get_header, [DecHash]) of
                        {ok, Hdr} ->
                            HdrHeight = aec_headers:height(Hdr),
                            Type = aec_headers:type(Hdr),
                            case Type of
                                key ->
                                    St1 = St#{ from => #{ height  => HdrHeight
                                                        , header  => Hdr }},
                                    do_rollback(St1, Node, Opts);
                                micro ->
                                    abort("Cannot roll back to a microblock")
                            end;
                        error ->
                            abort("Cannot find specified hash")
                    end
            end
    end.

do_rollback(Spec, _Node, _Opts) ->
    io:fwrite("Would rollback: ~p~n", [Spec]),
    ok.


abort(Str) ->
    abort(Str, []).

abort(Str, Args) ->
    io:fwrite(standard_error, Str ++ "~n", Args),
    halt(1).
